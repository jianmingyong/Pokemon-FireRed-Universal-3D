version=2
# This is a API for Random Dungeon Generator.
# Define Map Size.
@Storage.set(int,MapSizeX,50)
@Storage.set(int,MapSizeZ,50)

# Define Room Size.
@Storage.set(int,MinRoomSizeX,5)
@Storage.set(int,MaxRoomSizeX,10)
@Storage.set(int,MinRoomSizeZ,5)
@Storage.set(int,MaxRoomSizeZ,10)

# Define Number of Room.
@Storage.set(int,MinRoom,5)
@Storage.set(int,MaxRoom,5)

# Define Number of Tiles to be removed at the same time.
# The bigger the value, the faster it process but might lag at slow computer.
# Max value is 10.
@Storage.set(int,Processor,10)

##########################################################################################
######################## Do not touch anything beyond this line... #######################
##########################################################################################.
:if:<Register.registered(MysteryDungeon.SaveMap)>=false
	@Register.register(MysteryDungeon.SaveMap)
:endif
@Title.add(Generating... Please wait for a while.,2147483647,255,255,255,2,true,0,0)
# Dig a Random Location.
@Storage.set(int,MultiProcessor,<Math.clamp(<Storage.get(int,Processor)>,1,10)>)
@Storage.set(int,FinalRoom,<System.random(<Storage.get(int,MinRoom)>,<Storage.get(int,MaxRoom)>)>)

#. :if:<Register.registered(MysteryDungeon.SaveMap)>=false
	@Storage.set(int,FinalRoomSizeX,<System.random(<Storage.get(int,MinRoomSizeX)>,<Storage.get(int,MaxRoomSizeX)>)>)
	@Storage.set(int,FinalRoomSizeZ,<System.random(<Storage.get(int,MinRoomSizeZ)>,<Storage.get(int,MaxRoomSizeZ)>)>)
	@Storage.set(int,CurrentRoomLocationX,<System.random(1,<Storage.get(int,MapSizeX)>-1-<Storage.get(int,MaxRoomSizeX)>)>)
	@Storage.set(int,CurrentRoomLocationZ,<System.random(1,<Storage.get(int,MapSizeZ)>-1-<Storage.get(int,MaxRoomSizeZ)>)>)
#. :else
#.	@Storage.set(int,FinalRoomSizeX,<Register.value(Room1.CurrentRoomLocationX)>)
#.	@Storage.set(int,FinalRoomSizeZ,<Register.value(Room1.CurrentRoomLocationZ)>)
#.	@Storage.set(int,CurrentRoomLocationX,<Register.value(Room1.CurrentRoomLocationX)>)
#.	@Storage.set(int,CurrentRoomLocationZ,<Register.value(Room1.CurrentRoomLocationZ)>)
#. :endif

@Script.start(System\MysteryDungeon\GenerateRoom)

# Register Room Location.
:if:<Register.registered(Room1.CurrentRoomLocationX)>=false
	@Register.register(Room1.CurrentRoomLocationX,int,0)
:endif
:if:<Register.registered(Room1.CurrentRoomLocationZ)>=false
	@Register.register(Room1.CurrentRoomLocationZ,int,0)
:endif
:if:<Register.registered(Room1.FinalRoomSizeX)>=false
	@Register.register(Room1.FinalRoomSizeX,int,0)
:endif
:if:<Register.registered(Room1.FinalRoomSizeZ)>=false
	@Register.register(Room1.FinalRoomSizeZ,int,0)
:endif
@Register.change(Room1.CurrentRoomLocationX,<Storage.get(int,CurrentRoomLocationX)>)
@Register.change(Room1.CurrentRoomLocationZ,<Storage.get(int,CurrentRoomLocationZ)>)
@Register.change(Room1.FinalRoomSizeX,<Storage.get(int,FinalRoomSizeX)>)
@Register.change(Room1.FinalRoomSizeZ,<Storage.get(int,FinalRoomSizeZ)>)

# Check For Valid Walls to Dig.
@Storage.set(int,ValidWallN.X,<Storage.get(int,CurrentRoomLocationX)>)
@Storage.set(int,ValidWallN.Z,<Storage.get(int,CurrentRoomLocationZ)>-1)
@Storage.set(int,ValidWallS.X,<Storage.get(int,CurrentRoomLocationX)>)
@Storage.set(int,ValidWallS.Z,<Storage.get(int,CurrentRoomLocationZ)>+<Storage.get(int,FinalRoomSizeZ)>)
@Storage.set(int,ValidWallE.X,<Storage.get(int,CurrentRoomLocationX)>+<Storage.get(int,FinalRoomSizeX)>)
@Storage.set(int,ValidWallE.Z,<Storage.get(int,CurrentRoomLocationZ)>)
@Storage.set(int,ValidWallW.X,<Storage.get(int,CurrentRoomLocationX)>-1)
@Storage.set(int,ValidWallW.Z,<Storage.get(int,CurrentRoomLocationZ)>)
@Storage.set(int,CurrentWallN.X,<System.random(<Storage.get(int,ValidWallN.X)>,<Storage.get(int,ValidWallN.X)>+<Storage.get(int,FinalRoomSizeX)>-1)>)
@Storage.set(int,CurrentWallN.Z,<Storage.get(int,ValidWallN.Z)>)
@Storage.set(int,CurrentWallS.X,<System.random(<Storage.get(int,ValidWallS.X)>,<Storage.get(int,ValidWallS.X)>+<Storage.get(int,FinalRoomSizeX)>-1)>)
@Storage.set(int,CurrentWallS.Z,<Storage.get(int,ValidWallS.Z)>)
@Storage.set(int,CurrentWallE.X,<Storage.get(int,ValidWallE.X)>)
@Storage.set(int,CurrentWallE.Z,<System.random(<Storage.get(int,ValidWallE.Z)>,<Storage.get(int,ValidWallE.Z)>+<Storage.get(int,FinalRoomSizeZ)>-1)>)
@Storage.set(int,CurrentWallW.X,<Storage.get(int,ValidWallW.X)>)
@Storage.set(int,CurrentWallW.Z,<System.random(<Storage.get(int,ValidWallW.Z)>,<Storage.get(int,ValidWallW.Z)>+<Storage.get(int,FinalRoomSizeZ)>-1)>)
@Storage.set(int,WallDig,<System.random(5,10)>)
:if:<not><Math.int(<Storage.get(int,ValidWallN.Z)>-<Storage.get(int,WallDig)>)>=0 <and> <not><Math.int(<Storage.get(int,ValidWallN.Z)>-<Storage.get(int,WallDig)>)><0
	@Storage.set(int,ValidWallN,1)
:else
	@Storage.set(int,ValidWallN,0)
:endif
:if:<not><Math.int(<Storage.get(int,ValidWallS.Z)>+<Storage.get(int,WallDig)>)>=<Math.int(<Storage.get(int,MapSizeZ)>-1)> <and> <not><Math.int(<Storage.get(int,ValidWallS.Z)>+<Storage.get(int,WallDig)>)>><Math.int(<Storage.get(int,MapSizeZ)>-1)>
	@Storage.set(int,ValidWallS,1)
:else
	@Storage.set(int,ValidWallS,0)
:endif
:if:<not><Math.int(<Storage.get(int,ValidWallE.X)>+<Storage.get(int,WallDig)>)>=<Math.int(<Storage.get(int,MapSizeX)>-1)> <and> <not><Math.int(<Storage.get(int,ValidWallE.X)>+<Storage.get(int,WallDig)>)>><Math.int(<Storage.get(int,MapSizeX)>-1)>
	@Storage.set(int,ValidWallE,1)
:else
	@Storage.set(int,ValidWallE,0)
:endif
:if:<not><Math.int(<Storage.get(int,ValidWallW.X)>-<Storage.get(int,WallDig)>)>=0 <and> <not><Math.int(<Storage.get(int,ValidWallW.X)>-<Storage.get(int,WallDig)>)><0
	@Storage.set(int,ValidWallW,1)
:else
	@Storage.set(int,ValidWallW,0)
:endif
@Script.start(System\MysteryDungeon\GenerateWall)

# Warp Player to a walkable zone.
@Player.warp(<System.random(<Storage.get(int,CurrentRoomLocationX)>,<Storage.get(int,CurrentRoomLocationX)>+<Storage.get(int,FinalRoomSizeX)>-1)>,0.1,<System.random(<Storage.get(int,CurrentRoomLocationZ)>,<Storage.get(int,CurrentRoomLocationZ)>+<Storage.get(int,FinalRoomSizeZ)>-1)>)
@Level.update
@Title.clear
:end